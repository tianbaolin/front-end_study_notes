### 浏览器运行原理

####1. 浏览器组成

​		简单来说浏览器可以分为两部分，shell+内核。其中shell的种类相对比较多，内核则比较少。

Shell是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操 作，参数设置等等。它是调用内核来实现各种功能的。

内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。 从Mozilla将Gecko独立出来后，才有了外壳和内核的明确划分。目前主流的浏览器有IE6、IE8、Mozilla、FireFox、Opera、Safari、Chrome、Netscape等。

浏览器内核又可以分成两部分：渲染引擎(layout engineer或者Rendering Engine)和JS引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至 显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内 容的应用程序都需要内核。

JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。最开始渲染引 擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个ACID来测试引擎的兼容性和性 能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、 Presto、Webkit。

浏览器一般由以下组件构成 ：

* 用户界面。包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
* 浏览器引擎。在用户界面和呈现引擎之间传送指令。
* 呈现引擎。负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
* 网络。用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
  用户界面后端。用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
* JavaScript 解释器。用于解析和执行 JavaScript 代码。
* 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

####![2014_04_04_02](http://www.nowamagic.net/librarys/images/201404/2014_04_04_02.png)



####2. webkit组成

![51565428180_.pic_hd](https://pic1.zhimg.com/80/v2-8f924df48f292eb54f9c9183e8ecba1c_hd.jpg)

#### 3. Webkit 渲染流程

​	![v2-1b41dfcdc85868d47dd417e7301b57d6_hd](https://pic3.zhimg.com/80/v2-1b41dfcdc85868d47dd417e7301b57d6_hd.jpg)

####4. Js 解析过程

![v2-6651cb0abb096059b509a8474b31a220_hd](https://pic1.zhimg.com/80/v2-6651cb0abb096059b509a8474b31a220_hd.jpg)

#### 5. 浏览器内核线程

一个浏览器通常由以下线程组成：

- GUI 渲染线程
- JavaScript引擎线程
- 定时触发器线程
- 用户事件触发线程
- 网络请求线程

#### 6. eventloop 事件循环机制

​	事件循环包括3部分（调用栈，执行线程，任务队列）

![v2-b99218d9ed20ee1fc74bafb201934e38_hd](https://pic1.zhimg.com/80/v2-b99218d9ed20ee1fc74bafb201934e38_hd.jpg)

* 任务队列：

​		一个事件循环会有一个或者多个任务队列，每个任务队列都是一系列任务按照顺序组成的列表。

​		而多个任务列表源于：每个任务都有指定的任务源，相同的任务源的任务按顺序放在同一个任务列表里。不同的任务列表按照优先级执行任务。

* 任务源

  > **DOM操作任务源**
  > 此任务源用于对DOM操作作出反应，例如一个元素以非阻塞的方式插入文档。
  > **用户交互任务源**
  > 此任务源用于对用户交互作出反应，例如键盘或鼠标输入
  > 响应用户操作的事件必须使用task队列。
  > **网络任务源**
  > 此任务源用于响应网络活动。
  > **历史遍历任务源**
  > 此任务源用于将对history.back()和类似API的调用排队
  > 此外 setTimeout、setInterval、IndexDB 数据库操作等也是任务源。

* 宏任务与微任务

  * 一个事件循环至会有一个microtask列表，但可能会有多个macrotask列表。
  * microtask包括：
    * Promise.then
    * MutationObserver(监测dom变化)
    * Object.observe (方法用于异步地监视一个对象的修改已尽废除，用proxy替代)

* 事件循环流程

  * 从任务队列中取出最早的一个任务执行
    执行时产生堆栈
  * 执行 microtask 检查点（一次性清空微任务队列）
    如果microtask checkpoint的flag（标识）为false，则设为true。执行 队列中的所有 microtask，直到队列为空，然后将microtask checkpoint的flag设为flase
  * 执行 UI render 操作（可选）
    非每次循环必须，只要满足浏览器60HZ的频率即可
  * 重复1

#### 7. 性能优化

1. 编写正确的HTML 代码，浏览器在html解释的时候，遇到错误标签，会启动容错机制，开发者应当规避这些错误。
2. css优先，css优先于js引入，因为渲染树需要拿到DOM树和CSS规则，而js会停止DOM树的构建。
3. 可以用媒体查询（media query）加载css，来解除对渲染的阻塞，这样，只有当出现符合media的情况时，才会加载该资源。
4. 尽量不要使用css import 来加载css，@import无论写在哪一行，都会在页面加载完再加载css
5. 优化css选择器。浏览器在处理选择器时依照从右到左的原则，因此最右端的选择器应该是优先级最高的，比如 div > span.test 优于 div span。 两个原因，一是 .test 比 span更准确，二是，浏览器看到 > span.test 会去找 div 的子元素，而不加大于号，则会寻找全局的span标签。
6. 减少重绘重排
   2. 将多次对DOM的修改合并。或者，你先把它从渲染树移除（display：none），这会重排一次，然后你想做什么做什么
   2. 当你需要修改DOM节点样式时，不要一条一条改n次，直接定义好样式，修改css类即可，尽管chrome做了优化，并不会真的重绘/重排n次，但是不不能保证你没有强制重绘的代码破坏这个机制，更何况，作为开发者，应当有意识编写高质量代码
   3. 当需要频繁获取元素位置等信息时，可先缓存
   4. 不要使用table布局
   5. transform和opacity属性只会引起合成，所以写css动画的时候，注意两个属性的使用，尽量只开启GPU合成，而不重绘重排。
   6. 必要时使用函数防抖
7. 防止js阻塞页面，将script标签放在</body>前面，或者使用**defer** **async** 属性加载
8. 文件大小和文件数量做好平衡，不要因为数量太多，大大超过了浏览器可并行下载的资源数量，要不要因为文件太大，提高了单一资源加载的时间
9. 优化回滚。不要书写触发优化回滚的代码。



