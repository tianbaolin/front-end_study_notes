## 数据结构

### 1. 列表

在日常生活中，人们经常使用列表：待办事项列表、购物清单、最佳十名榜单等等。而计算机程序也在使用列表，在下面的条件下，选择列表作为数据结构就显得尤为有用：

- 数据结构较为简单
- 不需要在一个长序列中查找元素，或者对其进行排序

反之，如果数据结构非常复杂，列表的作用就没有那么大了。

### 2. 栈

栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。想象一下，我们平常在饭馆见到的一摞盘子就是现实世界常见的栈的例子，只能从最上面取盘子，盘子洗干净后，也只能放在最上面。栈被称为一种后入先出的数据结构。是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快。
使用条件：

- 只要数据的保存满足`后入先出或先进后出`的原理，都优先考虑使用栈.

### 3. 队列

队列也是一种列表，不同的是队列只能在队尾插入元素，在队首删除元素。想象一下，我们在银行排队，排在最前面的人第一个办理业务，而后面来的人只能排在队伍的后面，直到轮到他们为止。
使用条件：

- 只要数据的保存满足`先进先出、后入后出`的原理，都优先考虑使用队列

常见应用场景：

- 队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制
- 消息机制可以通过队列来实现，进程调度也是使用队列来实现

### 4. 链表

链表也是一种列表，为什么需要出现链表，JavaScript中数组的主要问题时，它们被实现成了对象，与其他语言（比如C++和Java）的数组相对，效率很低。如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。
使用条件：

- 链表几乎可以用在任何可以使用`一维数组`的情况中。如果需要随机访问，数组仍然是更好的选择。

![image-20190920161821045](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190920161821045.png)

### 5. 字典

字典是一种以`键-值`对行驶存储数据的数据结构，JavaScript中的Object类就是以字典的形式设计的。JavaScript可以通过实现字典类，让这种字典类型的对象使用起来更加简单，字典可以实现对象拥有的常见功能，并相应拓展自己想要的功能，而对象在JavaScript编写中随处可见，所以字典的作用也异常明显了。

### 6. 散列

散列（也称为哈希表）是一种的常用的数组存储技术，散列后的数组可以快速地插入或取用。散列使用的数据结构叫做散列表。在散列表上`插入、删除和取用数据`都非常快，但对于查找操作来说却效率低下，比如查找一组数组中的最大值和最小值。这些操作需要求助于其他数据结构，比如下面介绍的二叉查找树。

散列表在JavaScript中可以基于数组去进行设计。数组的长度是预先设定的，所有元素根据和该元素对应的键，保存在数组的特定位置，这里的键和对象的键是类似的概念。使用散列表存储数组时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。

但是即使使用一个高效的散列函数，依然存在将两个键映射为同一个值的可能，这种现象叫做碰撞。常见碰撞的处理方法有：`开链法`和`线性探测法`（具体概念有兴趣的可以网上自信了解）

使用条件：

- 可以用于数据的插入、删除和取用，不适用于查找数据

### 7. 图

图由边的集合及顶点的集合组成。地图是我们身边很常见的现实场景，比如每两个城镇都由某种道路相连。上面的每个城镇可以看作一个顶点，连接城镇的道路便是边。边由顶点对（v1, v2）定义，v1和v2分别是图中的两个顶点。顶点也有权重，也成为成本。如果一个图的顶点对是有序的，则称之为有向图（例如常见的流程图），反之，称之为无序图。
使用场景（用图对现实中的系统建模）：

- 交通系统，可以用顶点表示街道的十字路口，边可以表示街道。加权的边可以表示限速或者车道的数量。可以用该系统判断最佳路线及最有可能堵车的街道。
- 任何运输系统都可以用图来建模。比如，航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以表示从一个机场到另一个机场的航班成本，或两个机场间的距离，这取决于建模的对象是什么。

搜索图的算法主要有两种： 深度优先搜索和广度优先搜索。

### 8. 树

​		树状图是一种数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；

空集合也是树，称为空树。空树中没有结点。

结点的度：一个结点含有的子树的个数称为该结点的度；

叶结点或终端结点：度为0的结点称为叶结点；

非终端结点或分支结点：度不为0的结点；

双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点；

孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；

兄弟结点：具有相同父结点的结点互称为兄弟结点；

树的度：一棵树中，最大的结点的度称为树的度；

结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推；

树的高度或深度：树中结点的最大层次；

堂兄弟结点：双亲在同一层的结点互为堂兄弟；

结点的祖先：从根到该结点所经分支上的所有结点；

子孙：以某结点为根的子树中任一结点都称为该结点的子孙。

森林：由m（m>=0）棵互不相交的树的集合称为森林；

#### 1. 分类

* 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;

* [有序树](https://baike.baidu.com/item/有序树)：树中任意节点的子结点之间有顺序关系，这种树称为有序树；

* 二叉树：每个节点最多含有两个子树的树称为二叉树；
  二叉树每个节点的子节点不允许超过两个。一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为2，可以写出高效的程序在树中`插入、查找和删除数据`。
  
* 二叉查找树（BST）是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得`查找的效率很高`，对于数值型和非数值型的数据，比如单词和字符串，都是如此。

  1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
  2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
  3. 任意节点的左、右子树也分别为二叉查找树；
  4. 没有键值相等的节点。

  二叉查找树相比于其他数据结构的优势在于查找、插入的[时间复杂度](https://zh.wikipedia.org/wiki/时间复杂度)较低。为![O(\log n)](https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如[集合](https://zh.wikipedia.org/wiki/集合_(计算机科学))、[多重集](https://zh.wikipedia.org/wiki/多重集)、[关联数组](https://zh.wikipedia.org/wiki/关联数组)等。

![image-20190922122004279](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190922122004279.png)

遍历BST的方式有三种：中序遍历（以升序访问树中所有节点，先访问左节点，再访问根节点，最后访问右节点）【10 22 30 56 77 81 92】、先序遍历（先访问根节点，再以同样的方式访问左节点和右节点）【56 22 10 30 81 77 92】、后序遍历（先访问叶子节点，从左子树到右子树，再到根节点）【10 30 22 77 92 81 56】

* 红黑树

  是一种自平衡二叉查找树。改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

  1. 节点是红色或黑色。

  2. 根是黑色。

  3. 所有叶子都是黑色（叶子是NIL节点）。

  4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）

  5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。

     ![image-20190927105236814](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190927105236814.png)

这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的[二叉查找树](https://zh.wikipedia.org/wiki/二叉查找树)。

* 满二叉树

  除最后一层无任何子[节点](https://baike.baidu.com/item/节点/865052)外，每一层上的所有结点都有两个子结点的二叉树。

  ![image-20190922125132245](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190922125132245.png)

* 完全二叉树

  完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。

![image-20190922124943450](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190922124943450.png)

* 堆

  堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：

  * 堆中某个节点的值总是不大于或不小于其父节点的值；

  * 堆总是一棵完全二叉树。

    将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。
    堆是非线性数据结构，相当于一维数组，有两个直接后继。
    堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。
    (ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4...n/2)
    若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列{k1,k2,…,kn}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）

![image-20190922131553577](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190922131553577.png)

### 2. 遍历方法

#### 1. 按深度遍历

* 先序遍历 ABDEFGC

  ![image-20190927103014691](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190927103014691.png)

* 中序遍历 DEBGFAC

  ![image-20190927103043096](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190927103043096.png)

* 后序遍历 EDGFBCA

  ![image-20190927103108483](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190927103108483.png)

  #### 2. 按广度遍历 0123456789

  ![image-20190927103800044](/Users/tianbaolin/Library/Application Support/typora-user-images/image-20190927103800044.png)